import itertools
import logging

from pprint import pprint as _pprint


_LOG_NAME = "serialize"


def pprint(obj, *args, **kwargs):
    """Serialize and pretty-print interop object."""
    _pprint(serialize(obj), *args, **kwargs)


def serialize(obj):
    """Serialize an interop object into a JSON serializable format.

    This function is meant to help explore results generated by interop, by converting
    data-structures to a human-readable format. These results must NOT be used to carry
    out analyses or other data processing, as the function works by brute-forcing
    available methods on instances, which may lead to unintended side-effects.
    """
    if isinstance(obj, (int, float, bool, str)) or obj is None:
        return obj
    elif isinstance(obj, (list, tuple)):
        return type(obj)(serialize(value) for value in obj)

    classname = obj.__class__.__name__
    if hasattr(obj, "__getitem__"):
        return _serialize_vector(obj)

    log = logging.getLogger(_LOG_NAME)
    result = {"#": classname}
    for key in dir(obj):
        if key.startswith("_"):
            log.debug("skipping magic function %s.%s", classname, key)
            continue
        elif f"*.{key}" in _PROPERTIES_BLACKLIST:
            log.debug("skipping globally blacklisted function %s.%s", classname, key)
            continue
        elif f"{classname}.{key}" in _PROPERTIES_BLACKLIST:
            log.debug("skipping blacklisted function %s.%s", classname, key)
            continue

        value = getattr(obj, key)
        if callable(value):
            log.debug("calling %s.%s", classname, key)
            try:
                value = value()
            except Exception:
                log.warning("blacklisting %s.%s", classname, key)
                _PROPERTIES_BLACKLIST.add(f"{classname}.{key}")
                continue

        result[key] = serialize(value)

    if hasattr(obj, "at"):
        result["*"] = _serialize_vector(obj)

    return result


def _serialize_vector(obj):
    getter = None
    if hasattr(obj, "at"):
        getter = obj.at
    elif hasattr(obj, "__getitem__"):
        getter = obj.__getitem__
    else:
        raise AssertionError(f"{obj!r} is not a vector-like")

    result = []
    # There is no standard way to get the item count, so just try until it throws
    for idx in itertools.count():
        try:
            item = getter(idx)
        except Exception as error:
            print(repr(error))
            break

        result.append(serialize(item))

    return result


# List of functions known to fail or cause side-effects
_PROPERTIES_BLACKLIST = {
    "*.append_tiles",
    "*.at",
    "*.clear",
    "*.copy_by_tile",
    "*.copy_reads",
    "*.create_id",
    "*.default_header",
    "*.find",
    "*.get_metric_ref",
    "*.get_metric",
    "*.has_metric",
    "*.initialize",
    "*.insert",
    "*.lane_from_id",
    "*.metrics_for_cycle",
    "*.metrics_for_lane",
    "*.number",
    "*.phyiscalLocationColumn",
    "*.phyiscalLocationIndex",
    "*.phyiscalLocationRow",
    "*.physical_location_column",
    "*.physical_location_index",
    "*.physical_location_row",
    "*.reserve",
    "*.resize_stat",
    "*.resize",
    "*.section",
    "*.set_base",
    "*.set_version",
    "*.size",
    "*.sort",
    "*.surface",
    "*.swath",
    "*.this",
    "*.tile_from_id",
    "*.tile_hash_from_id",
    "*.tile_numbers_for_lane",
    "*.trim",
    "*.update",
}
